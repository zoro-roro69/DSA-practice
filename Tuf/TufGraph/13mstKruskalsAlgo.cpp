#include <bits/stdc++.h>
using namespace std;

// Kruskal algorithm for minimum spanning tree

// first sort the edges
// 1. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. 
//  If cycle is not formed, include this edge. Else, discard it. 
// 2. Repeat step 1 until there are (V-1) edges in the spanning tree.

// Step #2 uses the Union-Find algorithm to detect cycles.
// when we pick a edge u-v, we check if the two vertices u & v belong to the same set or not
// if they do, that means that it forms  cycle so it is discarded
// else, it does not form the cycle, so we include the edge in our mst, and do union/merge of u and v

// Time Complexity: O(ElogE) or O(ElogV), Sorting of edges takes O(ELogE) time. After sorting, we iterate
//  through all edges and apply the find-union algorithm. The find and union operations can take at most O(LogV) 
// time. So overall complexity is O(ELogE + ELogV) time. The value of E can be at most O(V2), so O(LogV) is 
// O(LogE) the same. Therefore, the overall time complexity is O(ElogE) or O(ElogV)
// Auxiliary Space: O(V + E), where V is the number of vertices and E is the number of edges in the graph




// Prims vs Kruskal 

// 1. prims start to build from any vertex ------ kruskal starts to build from mnimum edge
// 2. at any instance prims generate a connected graph -------- in between the graph generated by kruskal can be disconnected
// 3. prims algo works faster for dense graphs(graph with lots of edges) --------  works great when edges are less /sparse graph
struct edge{
    int u;
    int v;
    int wt;
};

struct mycompare{
    bool operator()(const edge &e1, const edge &e2)const {
        return e1.wt < e2.wt;
    }
};

int find_(int i, vector <int> &parent){
    if (i == parent[i])
        return i;
    return parent[i] = find_(parent[i], parent);
}

void merge(int i, int j, vector <int> &parent){
    int pi = find_(i, parent);
    int pj = find_(j, parent);
    if (pi!=pj){
        parent[pj] = pi;
    }
}

int spanningTreeKruskal(int v, vector<vector<int>> adj[]){
    vector <edge> edge_list;

    for (int i=0;i<v;i++){
        for (auto j:adj[i]){
            if (j[0] > i){
                edge_list.push_back({i, j[0], j[1]});
            }
        }
    }

    sort(edge_list.begin(), edge_list.end(), mycompare());

    vector <int> parent(v,0);
    
    for (int i=0;i<v;i++){
        parent[i] = i; //initially each vertex is representative of its own set
    }

    int res = 0;
    int n=0;
    for (auto e:edge_list){
        int par_u = find_(e.u, parent);
        int par_v = find_(e.v, parent);
        if (par_u != par_v){ 
            //merge
            parent[par_v] = par_u;
            res+= e.wt;
            n++;
        }
        if (n == v-1) //we got our v-1 edges in the spanning tree
            break;
    }

    return res;


}

int main()
{   
    freopen("input.txt", "r", stdin);
    int t;
    cin >> t;
    while (t--) {
        int V, E;
        cin >> V >> E;
        vector<vector<int>> adj[V];
        int i=0;
        while (i++<E) {
            int u, v, w;
            cin >> u >> v >> w;
            vector<int> t1,t2;
            t1.push_back(v);
            t1.push_back(w);
            adj[u].push_back(t1);
            t2.push_back(u);
            t2.push_back(w);
            adj[v].push_back(t2);
        }
    	cout << spanningTreeKruskal(V, adj) << "\n";
    }

    return 0;
}